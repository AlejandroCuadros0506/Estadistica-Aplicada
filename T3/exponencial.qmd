---
title: "Distribución Exponencial"
lang: es
---

```{=html}
<style>
main.content {
text-align: justify}
</style>
```

```{r}
#| include: false
#| label: setup

library(ggplot2)
library(dplyr)
library(gridExtra)
library(knitr)
library(kableExtra)
library(plotly)
```


La **distribución exponencial** es una de las distribuciones continuas más importantes en probabilidad y estadística, especialmente en el modelado de **tiempos de espera** y **procesos de fallo**. Su relevancia radica en su capacidad para modelar el tiempo que transcurre entre eventos que ocurren de manera aleatoria e independiente a una tasa constante.

La distribución exponencial surge naturalmente del **proceso de Poisson**, si los eventos siguen un proceso de Poisson con tasa $\lambda$, entonces el tiempo entre eventos consecutivos sigue una distribución exponencial con el mismo parámetro $\lambda$.

**Interpretación Práctica**

La distribución exponencial modela situaciones donde:

- **Tiempo entre llegadas**: Clientes a un banco, llamadas telefónicas, visitantes a un sitio web
- **Tiempo de vida**: Componentes electrónicos, vida útil de equipos
- **Tiempo de servicio**: Duración de llamadas telefónicas, tiempo de atención al cliente
- **Procesos de decaimiento**: Desintegración radiactiva, eliminación de medicamentos del cuerpo


::: {#def-exponencial}

Decimos que variable aleatoria continua $X$ tiene **distribución exponencial** con parámetro $\lambda > 0$ si tiene función de densidad de probabilidad:

\begin{equation}
f(x) = \begin{cases} 
\lambda e^{-\lambda x} & \text{si } x \geq 0 \\
0 & \text{si } x < 0
\end{cases}
\end{equation}

A una variable aleatoria con distribución exponencial se le denota como $X \sim \text{exp}(\lambda)$, donde $\lambda$ es el **parámetro de tasa** (rate parameter).

:::

---

**Parámetro de la Distribución**

La distribución exponencial tiene **un solo parámetro**:

- **$\lambda$ (lambda)**: Parámetro de tasa o intensidad
  - $\lambda > 0$ (debe ser positivo)
  - Representa la tasa promedio de ocurrencia de eventos por unidad de tiempo
  - **Mayor $\lambda$**: Eventos más frecuentes, tiempos de espera más cortos
  - **Menor $\lambda$**: Eventos menos frecuentes, tiempos de espera más largos



**Soporte y Dominio**

- **Soporte**: $[0, \infty)$, solo valores no negativos
- **Dominio natural**: Tiempo, distancia, o cualquier magnitud no negativa
- La distribución es **continua** en todo su soporte

## Propiedades de la Función de Densidad 

1. **Monótona decreciente**: La función siempre decrece desde su máximo en $x = 0$
2. **Asintótica**: Se aproxima a cero cuando $x \to \infty$
3. **Valor máximo**: $f(0) = \lambda$
4. **Forma**: Curva exponencial decreciente


**Comportamiento de la PDF al Variar $\lambda$**

```{r}
#| label: pdf-variacion-lambda

# Definir valores de x y diferentes valores de lambda
x_vals <- seq(0, 6, length.out = 1000)
lambdas <- c(0.5, 1, 1.5, 2, 3)

# Crear dataframe para ggplot
df_pdf <- data.frame()
for (lambda in lambdas) {
  temp_df <- data.frame(
    x = x_vals,
    y = dexp(x_vals, lambda),
    lambda = paste("λ =", lambda)
  )
  df_pdf <- rbind(df_pdf, temp_df)
}

# Gráfico de PDFs con diferentes λ
pdf_graf <- ggplot(df_pdf, aes(x = x, y = y, color = lambda)) +
  geom_line(linewidth = 1.2) +
  labs(title = "Función de Densidad - Distribución Exponencial",
       subtitle = "Efecto del parámetro λ en la forma de la distribución",
       x = "x",
       y = "f(x) = λe^(-λx)",
       color = "Parámetro") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "right") +
  scale_color_viridis_d() +
  xlim(0, 6)


ggplotly(pdf_graf)
```


## Propiedades de la Función de Distribución (CDF)

**Definición y Derivación**

La función de distribución acumulativa (CDF) de la distribución exponencial se obtiene integrando la PDF:

$$F(x) = P(X \leq x) = \int_{0}^{x} \lambda e^{-\lambda t} dt$$

**Cálculo de la Integral**

$$F(x) = \lambda \int_{0}^{x} e^{-\lambda t} dt$$

Usando la sustitución $u = -\lambda t$, $du = -\lambda dt$:


\begin{equation}
F(x) = \lambda \cdot \frac{1}{-\lambda} \int_{0}^{-\lambda x} e^{u} du = -\left[e^{-\lambda t}\right]_{0}^{x}
\end{equation}

\begin{equation}
F(x) = -\left(e^{-\lambda x} - e^{0}\right) = -(e^{-\lambda x} - 1) = 1 - e^{-\lambda x},
\end{equation}

es decir:

\begin{equation}
F(x) = \begin{cases} 
0 & \text{si } x < 0 \\
1 - e^{-\lambda x} & \text{si } x \geq 0
\end{cases}
\end{equation}

**Propiedades de la CDF**

- **Monótona creciente**: $F'(x) = f(x) \geq 0$
- **Continua**: No hay saltos en la función
- **Límites**: $\lim_{x \to 0^+} F(x) = 0$ y $\lim_{x \to \infty} F(x) = 1$


**Visualización de la CDF**

```{r}
#| label: cdf-variacion-lambda

# Crear dataframe para CDFs
df_cdf <- data.frame()
for (lambda in lambdas) {
  temp_df <- data.frame(
    x = x_vals,
    y = pexp(x_vals, lambda),
    lambda = paste("λ =", lambda)
  )
  df_cdf <- rbind(df_cdf, temp_df)
}

# Gráfico de CDFs
cdf_graf <- ggplot(df_cdf, aes(x = x, y = y, color = lambda)) +
  geom_line(linewidth = 1.2) +
  geom_hline(yintercept = c(0, 0.5, 1), linetype = "dashed", alpha = 0.5) +
  labs(title = "Función de Distribución Acumulativa - Distribución Exponencial",
       subtitle = "Efecto del parámetro λ en la CDF",
       x = "x",
       y = "F(x) = 1 - e^(-λx)",
       color = "Parámetro") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "right") +
  scale_color_viridis_d() +
  xlim(0, 6) +
  ylim(0, 1)


ggplotly(cdf_graf)
```

## Cálculo de Probabilidades

Para calcular $P(a \leq X \leq b)$ con $0 \leq a < b$, tenemos:

$$P(a \leq X \leq b) = F(b) - F(a) = (1 - e^{-\lambda b}) - (1 - e^{-\lambda a}) = e^{-\lambda a} - e^{-\lambda b}$$

**Ejemplo de Cálculo**

Consideremos una variable aleatoria $X \sim \text{exp}(\lambda = 2)$. Queremos calcular $P(1 \leq X \leq 3)$.


```{r ejemplos-probabilidades}
# Parámetros para el ejemplo
lambda_ej <- 2
a_ej <- 1
b_ej <- 3

# Calcular probabilidades
prob_menor_igual_b <- pexp(b_ej, lambda_ej)
prob_menor_igual_a <- pexp(a_ej, lambda_ej)
prob_intervalo <- prob_menor_igual_b - prob_menor_igual_a

# Mostrar cálculos
cat("P(X ≤ 3) =", round(prob_menor_igual_b, 4), "\n")
cat("P(X ≤ 1) =", round(prob_menor_igual_a, 4), "\n")
cat("P(1 ≤ X ≤ 3) =", round(prob_intervalo, 4), "\n")
```

**Visualización del Área Bajo la Curva**

```{r area-bajo-curva}
# Crear gráfico mostrando el área bajo la curva
x_area <- seq(0, 5, length.out = 1000)
y_area <- dexp(x_area, lambda_ej)

# Identificar puntos en el intervalo [1, 3]
x_intervalo <- x_area[x_area >= a_ej & x_area <= b_ej]
y_intervalo <- y_area[x_area >= a_ej & x_area <= b_ej]

ggplot(data.frame(x = x_area, y = y_area), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_area(data = data.frame(x = x_intervalo, y = y_intervalo),
            aes(x = x, y = y), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = c(a_ej, b_ej), linetype = "dashed", color = "red") +
  annotate("text", x = 2, y = 0.5, 
           label = paste("P(1 ≤ X ≤ 3) =", round(prob_intervalo, 3)),
           size = 5, color = "red", fontface = "bold") +
  labs(title = "Cálculo de Probabilidades usando el Área bajo la Curva",
       subtitle = "Distribución Exponencial λ = 2",
       x = "x", y = "f(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  xlim(0, 5)
```

## Cuantiles de la Distribución

**Función Cuantil (Inversa de la CDF)**

Para encontrar el cuantil $x_p$ tal que $P(X \leq x_p) = p$:

$$p = 1 - e^{-\lambda x_p}$$
$$e^{-\lambda x_p} = 1 - p$$
$$-\lambda x_p = \ln(1 - p)$$
$$x_p = -\frac{\ln(1 - p)}{\lambda}$$

**Cuantiles Importantes**

Consideremos la distribución $X \sim \text{exp}(\lambda = 1.5)$ y calculemos algunos cuantiles importantes.

```{r}
#| label: cuantiles-importantes


# Calcular cuantiles importantes
lambda_cuant <- 1.5
cuantiles_p <- c(0.25, 0.5, 0.75, 0.9, 0.95, 0.99)

cuantiles_valores <- qexp(cuantiles_p, lambda_cuant)

# Crear tabla de cuantiles
tabla_cuantiles <- data.frame(
  Percentil = paste0(cuantiles_p * 100, "%"),
  Probabilidad = cuantiles_p,
  Cuantil = round(cuantiles_valores, 4),
  `Interpretación` = c(
    "Primer cuartil",
    "Mediana",
    "Tercer cuartil", 
    "Percentil 90",
    "Percentil 95",
    "Percentil 99"
  ),
  check.names = FALSE
)

kable(tabla_cuantiles,
      caption = paste("Cuantiles importantes para Exp(λ =", lambda_cuant, ")")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

**Visualización de Cuantiles en la CDF**

```{r cuantiles-visual}
# Crear gráfico de CDF con cuantiles marcados
x_cuant <- seq(0, 4, length.out = 1000)
y_cuant <- pexp(x_cuant, lambda_cuant)

# Puntos importantes
mediana <- qexp(0.5, lambda_cuant)
q1 <- qexp(0.25, lambda_cuant)
q3 <- qexp(0.75, lambda_cuant)

ggplot(data.frame(x = x_cuant, y = y_cuant), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_hline(yintercept = c(0.25, 0.5, 0.75), linetype = "dashed", alpha = 0.7) +
  geom_vline(xintercept = c(q1, mediana, q3), linetype = "dashed", alpha = 0.7) +
  annotate("point", x = q1, y = 0.25, color = "red", size = 3) +
  annotate("point", x = mediana, y = 0.5, color = "red", size = 3) +
  annotate("point", x = q3, y = 0.75, color = "red", size = 3) +
  annotate("text", x = q1, y = 0.15, label = "Q1", size = 4, color = "red") +
  annotate("text", x = mediana, y = 0.4, label = "Q2", size = 4, color = "red") +
  annotate("text", x = q3, y = 0.65, label = "Q3", size = 4, color = "red") +
  labs(title = "Cuantiles en la Función de Distribución Acumulativa",
       subtitle = paste("Exp(λ =", lambda_cuant, ")"),
       x = "x", y = "F(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Medidas Descriptivas

### Medidas de Tendencia Central

**Media (Esperanza)**

La media de la distribución exponencial se calcula como:

$$E(X) = \int_{0}^{\infty} x \cdot \lambda e^{-\lambda x} dx$$

Usando integración por partes con $u = x$ y $dv = \lambda e^{-\lambda x} dx$:

$$E(X) = \left[-x e^{-\lambda x}\right]_{0}^{\infty} + \int_{0}^{\infty} e^{-\lambda x} dx$$

El primer término se evalúa como cero, y el segundo:

$$E(X) = \int_{0}^{\infty} e^{-\lambda x} dx = \left[-\frac{1}{\lambda} e^{-\lambda x}\right]_{0}^{\infty} = \frac{1}{\lambda},$$

es decir: 
 
 $$\mu = E(X) = \frac{1}{\lambda}$$

**Mediana**

La mediana $m$ satisface $P(X \leq m) = 0.5$,

$$F(m) = 1 - e^{-\lambda m} = 0.5$$
$$e^{-\lambda m} = 0.5$$
$$-\lambda m = \log(0.5) = -\log(2)$$
$$m = \frac{\log(2)}{\lambda}$$

**Relación Media-Mediana**

$$\frac{\text{Mediana}}{\text{Media}} = \frac{\log(2)/\lambda}{1/\lambda} = \log(2) \approx 0.693$$

La mediana siempre es aproximadamente el **69.3%** de la media.

Consideremos la distribución $X \sim \text{exp}(\lambda = 1.5)$, en este caso la media es $\mu = \frac{1}{1.5} \approx 0.6667$ y la mediana es $m = \frac{\log(2)}{1.5} \approx 0.4621$. Luego, se verifica que $\frac{m}{\mu} \approx 0.693$.

```{r}
#| label:  medidas-tendencia-central

lambda_ejemplo <- 1.5

# Calcular medidas
media_ej <- 1 / lambda_ejemplo
mediana_ej <- log(2) / lambda_ejemplo

# Crear gráfico comparativo
x_vals <- seq(0, 4, length.out = 1000)
y_vals <- dexp(x_vals, lambda_ejemplo)

ggplot(data.frame(x = x_vals, y = y_vals), aes(x = x, y = y)) +
  geom_line(linewidth = 1.5, color = "blue") +
  geom_vline(xintercept = mediana_ej, color = "olivedrab", linewidth = 1.2, linetype = "dashed") +
  geom_vline(xintercept = media_ej, color = "orange2", linewidth = 1.2, linetype = "dotted") +
  annotate("text", x = mediana_ej + 0.05, y = 0.8, 
           label = paste("Mediana =", round(mediana_ej, 3)), color = "olivedrab", size = 4, angle = 90, hjust = 0) +
  annotate("text", x = media_ej + 0.05, y = 0.6, 
           label = paste("Media =", round(media_ej, 3)), color = "orange2", size = 4, angle = 90, hjust = 0) +
  labs(title = "Medidas de Tendencia Central - Distribución Exponencial",
       subtitle = paste("λ =", lambda_ejemplo),
       x = "x", y = "f(x)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))

```


### Medidas de Dispersión

**Varianza**

Para calcular la varianza, necesitamos $E(X^2)$:

$$E(X^2) = \int_{0}^{\infty} x^2 \cdot \lambda e^{-\lambda x} dx$$

Usando integración por partes dos veces:

$$E(X^2) = \frac{2}{\lambda^2}$$

Por lo tanto:

$$\text{Var}(X) = E[X^2] - (E[X])^2 = \frac{2}{\lambda^2} - \left(\frac{1}{\lambda}\right)^2 = \frac{2}{\lambda^2} - \frac{1}{\lambda^2} = \frac{1}{\lambda^2},$$

es decir:


$$\sigma^2 = \text{Var}(X) = \frac{1}{\lambda^2}$$

**Desviación Estándar**

$$\sigma = \sqrt{\text{Var}(X)} = \sqrt{\frac{1}{\lambda^2}} = \frac{1}{\lambda}$$



**Observación**: Para la distribución exponencial, $\sigma = \mu$. La desviación estándar es igual a la media.


### Medida de Forma

**Coeficiente de Variación**

El coeficiente de variación mide la dispersión relativa:

$$CV = \frac{\sigma}{\mu} = \frac{1/\lambda}{1/\lambda} = 1$$

Esta es una característica única y distintiva de la distribución exponencial. Sin importar el valor de $\lambda$, el coeficiente de variación siempre es exactamente 1.




## Simulación y Comparación con Parámetros Teóricos

Consideremos una distribución $\text{exp}(\lambda = 2)$ y evaluemos cómo los estadísticos muestrales convergen a los valores teóricos:

```{r simulacion-convergencia}
# Parámetros de la distribución
lambda_sim <- 2

# Parámetros teóricos
media_teorica <- 1 / lambda_sim
varianza_teorica <- 1 / lambda_sim^2
desv_std_teorica <- 1 / lambda_sim
mediana_teorica <- log(2) / lambda_sim

# Tamaños de muestra a evaluar
size_muestras <- c(50, 100, 500, 1000, 5000, 10000)

# Función para calcular estadísticos muestrales
calcular_estadisticos <- function(n, lambda) {
  muestra <- rexp(n, rate = lambda)
  
  return(data.frame(
    n = n,
    media_muestral = mean(muestra),
    varianza_muestral = var(muestra),
    desv_std_muestral = sd(muestra),
    mediana_muestral = median(muestra),
    min_muestral = min(muestra),
    max_muestral = max(muestra)
  ))
}

# Realizar simulaciones
resultados_sim <- do.call(rbind, lapply(size_muestras, calcular_estadisticos, lambda = lambda_sim))

# Agregar valores teóricos
resultados_sim$media_teorica <- media_teorica
resultados_sim$varianza_teorica <- varianza_teorica
resultados_sim$desv_std_teorica <- desv_std_teorica
resultados_sim$mediana_teorica <- mediana_teorica

# Calcular errores relativos
resultados_sim$error_media <- abs(resultados_sim$media_muestral - media_teorica) / media_teorica * 100
resultados_sim$error_varianza <- abs(resultados_sim$varianza_muestral - varianza_teorica) / varianza_teorica * 100

# Mostrar tabla de resultados
kable(resultados_sim[, c("n", "media_muestral", "media_teorica", "error_media", 
                        "varianza_muestral", "varianza_teorica", "error_varianza")],
      caption = "Convergencia de estadísticos muestrales hacia valores teóricos",
      digits = 4,
      col.names = c("n", "Media Muestral", "Media Teórica", "Error %", 
                    "Varianza Muestral", "Varianza Teórica", "Error %")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  add_header_above(c(" " = 1, "Media" = 3, "Varianza" = 3))
```

<br>

**Visualización de la Convergencia**

```{r convergencia-visual}
#| warning: false

# Generar una secuencia larga para observar convergencia
n_total <- 15000
muestra_larga <- rexp(n_total, rate = lambda_sim)

# Calcular estadísticos acumulados
indices <- 1:n_total
medias_acumuladas <- cumsum(muestra_larga) / indices
varianzas_acumuladas <- sapply(indices, function(i) var(muestra_larga[1:i]))

# Crear dataframe para gráficos
df_convergencia <- data.frame(
  n = indices,
  media_acumulada = medias_acumuladas,
  varianza_acumulada = varianzas_acumuladas
)

# Gráfico de convergencia de la media
p1 <- ggplot(df_convergencia, aes(x = n)) +
  geom_line(aes(y = media_acumulada), color = "blue", alpha = 0.8) +
  geom_hline(yintercept = media_teorica, color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Convergencia de la Media Muestral",
       x = "Tamaño de muestra (n)",
       y = "Media acumulada",
       caption = "Línea roja: Media teórica = 0.5") +
  theme_minimal() +
  ylim(0.4, 0.6)

# Gráfico de convergencia de la varianza
p2 <- ggplot(df_convergencia, aes(x = n)) +
  geom_line(aes(y = varianza_acumulada), color = "green", alpha = 0.8) +
  geom_hline(yintercept = varianza_teorica, color = "red", linetype = "dashed", linewidth = 1) +
  labs(title = "Convergencia de la Varianza Muestral",
       x = "Tamaño de muestra (n)",
       y = "Varianza acumulada",
       caption = "Línea roja: Varianza teórica = 0.25") +
  theme_minimal() +
  ylim(0.15, 0.35)

# Mostrar ambos gráficos
grid.arrange(p1, p2, ncol = 2,
             top = "Ley de Grandes Números - Distribución Exponencial (λ = 2)")
```

**Comparación Histograma vs Densidad Teórica**

```{r histograma-densidad}
#| warning: false

# Generar muestra grande para histograma
muestra_grande <- rexp(8000, rate = lambda_sim)

# Crear histograma con densidad teórica superpuesta
ggplot(data.frame(x = muestra_grande), aes(x = x)) +
  geom_histogram(aes(y = after_stat(density)), bins = 40, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  stat_function(fun = dexp, args = list(rate = lambda_sim), 
                color = "red", linewidth = 2) +
  labs(title = "Histograma de Muestra vs Densidad Teórica",
       subtitle = paste("8000 observaciones de Exp(λ =", lambda_sim, ")"),
       x = "Valores",
       y = "Densidad",
       caption = "Curva roja: Densidad teórica") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  xlim(0, 4)
```



## Ejemplos Prácticos

::: {#exm-tiempo_clientes}

### Tiempo entre llegadas de clientes

Un banco ha observado que los clientes llegan siguiendo un proceso de Poisson con una tasa promedio de 3 clientes por minuto. El tiempo entre llegadas consecutivas sigue una distribución exponencial.

```{r ejemplo-banco}
#| label: ejemplo-banco-tidy
#| warning: false


# --- 1. Parámetros del Problema ---
arrival_rate <- 3  # clientes por minuto
workday_minutes <- 480 # 8 horas

# --- 2. Simulación y Procesamiento de Datos ---
set.seed(123) # Para reproducibilidad

# Se generan ~3*480*1.5 = 2160 eventos para asegurar que cubrimos las 8 horas
simulation_data <- tibble(
  time_between = rexp(2500, rate = arrival_rate)
) %>%
  # Calculamos el momento exacto de cada llegada
  mutate(arrival_timestamp = cumsum(time_between)) %>%
  # Filtramos solo las llegadas que ocurren dentro de la jornada laboral
  filter(arrival_timestamp <= workday_minutes)

# --- 3. Cálculo de Estadísticos ---
# Extraemos los tiempos válidos para los cálculos
valid_times <- simulation_data$time_between
n_customers <- length(valid_times)

# Estadísticos de la simulación
simulated_mean_time <- mean(valid_times)
simulated_median_time <- median(valid_times)

# Probabilidades teóricas
prob_under_30s <- pexp(0.5, rate = arrival_rate)
prob_over_1min <- 1 - pexp(1, rate = arrival_rate)
prob_between_30s_90s <- pexp(1.5, rate = arrival_rate) - pexp(0.5, rate = arrival_rate)

# --- 4. Resultados del Análisis ---
cat("=== ANÁLISIS DE LLEGADAS AL BANCO (VERSIÓN TIDY) ===\n")
cat("Tasa (λ):", arrival_rate, "clientes/minuto\n")
cat("Tiempo promedio teórico (1/λ):", round(1/arrival_rate, 3), "minutos\n")
cat("Tiempo promedio simulado:", round(simulated_mean_time, 3), "minutos\n")
cat("Tiempo mediano simulado:", round(simulated_median_time, 3), "minutos\n")
cat("Clientes simulados en 8 horas:", n_customers, "\n\n")
cat("--- PROBABILIDADES TEÓRICAS ---\n")
cat("P(Tiempo < 0.5 min):", round(prob_under_30s, 3), "\n")
cat("P(Tiempo > 1.0 min):", round(prob_over_1min, 3), "\n")
cat("P(0.5 min < Tiempo < 1.5 min):", round(prob_between_30s_90s, 3), "\n")

# --- 5. Visualización ---
ggplot(simulation_data, aes(x = time_between)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "#85C1E9", color = "#1B4F72", alpha = 0.8) + # Nuevos colores
  stat_function(fun = dexp, args = list(rate = arrival_rate), 
                color = "#E74C3C", linewidth = 1.5) + # Color rojo vibrante
  geom_vline(xintercept = 1/arrival_rate, color = "#2ECC71", linetype = "dashed", linewidth = 1.2) +
  geom_vline(xintercept = c(0.5, 1, 1.5), color = "#F1C40F", linetype = "dotted", linewidth = 1) +
  labs(
    title = "Distribución Simulada de Tiempos entre Llegadas",
    x = "Tiempo entre llegadas (minutos)",
    y = "Densidad de Probabilidad",
    caption = "Curva Roja: Densidad Teórica | Línea Verde: Media Teórica | Líneas Amarillas: 30s, 60s, 90s"
  ) +
  theme_light() + # Nuevo tema
  coord_cartesian(xlim = c(0, 3)) # Forma segura de hacer zoom sin perder datos
```

:::

---

::: {#exm-vida_util_leds}

### Vida Útil de Componentes Electrónicos

Una empresa de electrónicos ha determinado que la vida útil de sus LEDs sigue una distribución exponencial con una vida útil promedio de 2000 horas.

```{r ejemplo-leds}
#| label: ejemplo-leds-tidy



# --- 1. Parámetros del Problema ---
avg_lifespan_hrs <- 2000
lambda_rate <- 1 / avg_lifespan_hrs
n_sim_leds <- 5000
warranty_hrs <- 1000

# --- 2. Simulación y Creación del Data Frame ---
set.seed(456) # Para reproducibilidad

simulation_df <- tibble(
  lifespan = rexp(n_sim_leds, rate = lambda_rate)
)

# --- 3. Análisis de Garantía ---
warranty_analysis <- simulation_df %>%
  summarise(
    failed_in_warranty = sum(lifespan < warranty_hrs),
    failure_percentage = (failed_in_warranty / n_sim_leds) * 100
  )

# Probabilidad teórica de fallo
theoretical_failure_prob <- pexp(warranty_hrs, rate = lambda_rate) * 100

# --- 4. Análisis de Percentiles ---
percentile_values <- c(10, 25, 50, 75, 90)
lifespan_at_percentiles <- qexp(percentile_values / 100, rate = lambda_rate)

# --- 5. Propiedad Sin Memoria ---
# P(dura 500h más | ya funcionó 1500h)
additional_hrs <- 500
memoryless_prob <- 1 - pexp(additional_hrs, rate = lambda_rate)
# P(dura 500h desde el inicio) para comparar
initial_prob_500h <- 1 - pexp(additional_hrs, rate = lambda_rate)

# --- 6. Imprimir Resultados ---
cat("=== ANÁLISIS DE VIDA ÚTIL DE LEDs (VERSIÓN TIDY) ===\n")
cat("Vida útil promedio teórica:", avg_lifespan_hrs, "horas\n")
cat("Vida útil promedio simulada:", round(mean(simulation_df$lifespan), 1), "horas\n")
cat("Mediana de vida útil simulada:", round(median(simulation_df$lifespan), 1), "horas\n\n")

cat("--- ANÁLISIS DE GARANTÍA (", warranty_hrs, " horas) ---\n", sep = "")
cat("Fallos simulados:", warranty_analysis$failed_in_warranty, "de", n_sim_leds, "\n")
cat("Porcentaje de fallos (Simulado):", round(warranty_analysis$failure_percentage, 2), "%\n")
cat("Porcentaje de fallos (Teórico):", round(theoretical_failure_prob, 2), "%\n\n")

cat("--- PERCENTILES DE VIDA ÚTIL ---\n")
# Creamos un data frame para mostrar los percentiles de forma ordenada
percentile_table_display <- tibble(
  Percentil = percentile_values,
  Horas = round(lifespan_at_percentiles, 1)
)
# Imprimir usando print para un formato de tabla simple
print(percentile_table_display)


cat("\n--- PROPIEDAD SIN MEMORIA ---\n")
cat("P(dure 500h más | ya funcionó 1500h):", round(memoryless_prob, 3), "\n")
cat("P(dure 500h desde el inicio):", round(initial_prob_500h, 3), "(idéntica)\n")

# --- 7. Tabla de Percentiles con kableExtra ---
percentile_table_kable <- tibble(
  Percentil = paste0(percentile_values, "%"),
  `Vida Útil (horas)` = round(lifespan_at_percentiles, 1),
  `Años (aprox.)` = round(lifespan_at_percentiles / (24 * 365), 2)
)

kable(percentile_table_kable, caption = "Percentiles de Vida Útil de LEDs") %>%
  kable_styling(bootstrap_options = "condensed", full_width = FALSE)

# --- 8. Gráfico de Distribución ---
# Encontrar un buen punto para las etiquetas de texto
max_density <- max(density(simulation_df$lifespan)$y)

ggplot(simulation_df, aes(x = lifespan)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#FAD7A0", color = "#784212", alpha = 0.8) +
  stat_function(fun = dexp, args = list(rate = lambda_rate),
                color = "#C0392B", linewidth = 1.5) +
  geom_vline(xintercept = warranty_hrs, color = "#2980B9", linetype = "dashed", linewidth = 1.2) +
  geom_vline(xintercept = avg_lifespan_hrs, color = "#27AE60", linetype = "dashed", linewidth = 1.2) +
  annotate("text", x = warranty_hrs, y = max_density * 0.85,
           label = paste("Garantía\n", warranty_hrs, "h"), color = "#2980B9", size = 4, hjust = -0.1) +
  annotate("text", x = avg_lifespan_hrs, y = max_density * 0.65,
           label = paste("Vida Promedio\n", avg_lifespan_hrs, "h"), color = "#27AE60", size = 4, hjust = -0.1) +
  labs(
    title = "Distribución Simulada de la Vida Útil de LEDs",
    x = "Vida útil (horas)",
    y = "Densidad de Probabilidad"
  ) +
  theme_bw() +
  coord_cartesian(xlim = c(0, 8000))
```

:::



::: {#exm-tiempo_servidor}

### Tiempo de Respuesta de un Servidor Web

Un servidor web procesa solicitudes con un tiempo de respuesta que sigue una distribución exponencial con un tiempo promedio de 200 milisegundos.

```{r ejemplo-servidor}
#| label: ejemplo-servidor-tidy

# Cargar librerías
library(ggplot2)
library(dplyr)
library(gridExtra)
library(grid)

# --- 1. Parámetros del Problema ---
avg_response_s <- 0.2  # 200 ms
lambda_rate <- 1 / avg_response_s
n_requests <- 10000

# --- 2. Simulación y Creación del Data Frame ---
set.seed(42) # Para reproducibilidad

simulation_df <- tibble(
  response_s = rexp(n_requests, rate = lambda_rate)
) %>%
  mutate(
    response_ms = response_s * 1000
  )

# --- 3. Análisis de Rendimiento y SLA ---
# Calcular métricas de la simulación
performance_summary <- simulation_df %>%
  summarise(
    avg_ms = mean(response_ms),
    median_ms = median(response_ms),
    sla_100ms_pct = mean(response_ms <= 100) * 100,
    sla_500ms_pct = mean(response_ms <= 500) * 100,
    sla_1000ms_pct = mean(response_ms <= 1000) * 100,
    long_tail_count = sum(response_ms > 1000),
    long_tail_pct = mean(response_ms > 1000) * 100
  )

# Calcular probabilidades teóricas
theoretical_probs <- tibble(
  sla_100ms_pct = pexp(0.1, rate = lambda_rate) * 100,
  sla_500ms_pct = pexp(0.5, rate = lambda_rate) * 100,
  sla_1000ms_pct = pexp(1.0, rate = lambda_rate) * 100
)

# Calcular percentiles teóricos
percentile_levels <- c(50, 90, 95, 99)
percentile_values_ms <- qexp(percentile_levels / 100, rate = lambda_rate) * 1000

# --- 4. Imprimir Resultados ---
cat("=== ANÁLISIS DE SERVIDOR WEB (VERSIÓN TIDY) ===\n")
cat("Tiempo promedio teórico:", avg_response_s * 1000, "ms\n")
cat("Tiempo promedio simulado:", round(performance_summary$avg_ms, 1), "ms\n")
cat("Tiempo mediano simulado:", round(performance_summary$median_ms, 1), "ms\n\n")

cat("--- CUMPLIMIENTO DE SLA ---\n")
cat("≤ 100ms - Simulado:", round(performance_summary$sla_100ms_pct, 1), "% | Teórico:", round(theoretical_probs$sla_100ms_pct, 1), "%\n")
cat("≤ 500ms - Simulado:", round(performance_summary$sla_500ms_pct, 1), "% | Teórico:", round(theoretical_probs$sla_500ms_pct, 1), "%\n")
cat("≤ 1000ms - Simulado:", round(performance_summary$sla_1000ms_pct, 1), "% | Teórico:", round(theoretical_probs$sla_1000ms_pct, 1), "%\n\n")

cat("--- PERCENTILES DE TIEMPO DE RESPUESTA ---\n")
percentiles_df <- tibble(Percentil = paste0("P", percentile_levels), `Tiempo (ms)` = round(percentile_values_ms, 1))
print(percentiles_df)

cat("\n--- ANÁLISIS DE COLA LARGA (Long Tail) ---\n")
cat("Solicitudes > 1000ms:", performance_summary$long_tail_count, "de", n_requests,
    "(", round(performance_summary$long_tail_pct, 2), "%)\n")

# --- 5. Visualización ---
# Gráfico 1: Histograma de Tiempos de Respuesta
p1 <- ggplot(simulation_df, aes(x = response_ms)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50,
                 fill = "#7D3C98", color = "white", alpha = 0.8) + # Color morado
  stat_function(
    fun = function(x) dexp(x / 1000, rate = lambda_rate) / 1000,
    color = "#F1C40F", linewidth = 1.5 # Color amarillo
  ) +
  geom_vline(xintercept = c(100, 500, 1000), color = "#5DADE2", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribución de Tiempos de Respuesta",
    x = "Tiempo de respuesta (ms)", y = "Densidad"
  ) +
  theme_dark() + # Nuevo tema
  coord_cartesian(xlim = c(0, 1500))

# Gráfico 2: Función de Supervivencia
survival_df <- tibble(
  time_ms = seq(0, 2000, by = 10),
  survival_prob = 1 - pexp(time_ms / 1000, rate = lambda_rate)
)

p2 <- ggplot(survival_df, aes(x = time_ms, y = survival_prob)) +
  geom_line(color = "#2ECC71", linewidth = 1.5) + # Color verde
  geom_hline(yintercept = c(0.1, 0.05, 0.01), color = "gray70", linetype = "dotted") +
  scale_y_continuous(labels = scales::percent_format()) + # Eje Y en porcentaje
  labs(
    title = "Función de Supervivencia",
    x = "Tiempo de respuesta (ms)", y = "Probabilidad de ser MÁS LENTO que t"
  ) +
  theme_dark()

# Combinar gráficos
grid.arrange(p1, p2, ncol = 2,
             top = textGrob("Análisis de Rendimiento del Servidor Web", gp = gpar(fontsize = 16, col = "white")))
```

:::

## Verificación del Teorema Central del Límite por Simulación

El Teorema Central del Límite establece que las medias muestrales de cualquier distribución (con media y varianza finitas) se aproximan a una distribución normal cuando el tamaño de muestra es suficientemente grande.



```{r tcl-setup}
# Parámetros de la distribución exponencial base
lambda_tcl <- 1.5
media_poblacional <- 1 / lambda_tcl
varianza_poblacional <- 1 / lambda_tcl^2

# Diferentes tamaños de muestra
size_muestra <- c(5, 10, 20, 30, 50, 100)
num_muestras <- 2000  # Número de medias muestrales a generar por tamaño

# Función para generar medias muestrales
generar_medias_exp <- function(n, num_sim, lambda) {
  medias <- replicate(num_sim, mean(rexp(n, rate = lambda)))
  return(medias)
}

# Generar medias para cada tamaño de muestra
resultados_tcl <- list()
for (i in seq_along(size_muestra)) {
  n <- size_muestra[i]
  medias <- generar_medias_exp(n, num_muestras, lambda_tcl)
  
  # Calcular estadísticos de las medias
  media_de_medias <- mean(medias)
  varianza_de_medias <- var(medias)
  
  resultados_tcl[[i]] <- data.frame(
    medias = medias,
    n = n,
    media_teorica_medias = media_poblacional,
    varianza_teorica_medias = varianza_poblacional / n,
    desv_std_teorica_medias = sqrt(varianza_poblacional / n),
    media_observada_medias = media_de_medias,
    varianza_observada_medias = varianza_de_medias
  )
}

# Combinar resultados
df_tcl <- do.call(rbind, resultados_tcl)
df_tcl$n_factor <- factor(paste("n =", df_tcl$n), 
                         levels = paste("n =", size_muestra))
```

**Visualización de la Normalización Progresiva**

```{r tcl-histogramas}
# Crear datos para las curvas normales teóricas
df_normal_teorica <- data.frame()
x_range <- seq(min(df_tcl$medias) - 0.1, max(df_tcl$medias) + 0.1, length.out = 200)

for (n in size_muestra) {
  df_temp <- data.frame(
    x = x_range,
    y = dnorm(x_range, mean = media_poblacional, sd = sqrt(varianza_poblacional/n)),
    n_factor = paste("n =", n)
  )
  df_normal_teorica <- rbind(df_normal_teorica, df_temp)
}

# Crear histogramas para cada tamaño de muestra
ggplot(df_tcl, aes(x = medias)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, 
                 fill = "lightblue", color = "black", alpha = 0.7) +
  geom_vline(aes(xintercept = media_teorica_medias), 
             color = "red", linetype = "dashed", linewidth = 1) +
  # Superponer curva normal teórica
  geom_line(data = df_normal_teorica, aes(x = x, y = y), 
            color = "red", linewidth = 1.5, alpha = 0.8) +
  facet_wrap(~n_factor, scales = "free_y", ncol = 3) +
  labs(title = "Teorema Central del Límite - Distribución Exponencial",
       subtitle = paste("Distribución de medias muestrales para Exp(λ =", lambda_tcl, ")"),
       x = "Media muestral",
       y = "Densidad",
       caption = "Línea roja: Media teórica | Curva roja: Normal teórica") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


```{r tcl-varianza}
# Calcular estadísticos resumidos por tamaño de muestra
estadisticos_tcl <- df_tcl %>%
  group_by(n) %>%
  summarise(
    media_observada = mean(medias),
    varianza_observada = var(medias),
    desv_std_observada = sd(medias),
    varianza_teorica = first(varianza_teorica_medias),
    desv_std_teorica = first(desv_std_teorica_medias),
    error_varianza = abs(var(medias) - first(varianza_teorica_medias)),
    .groups = 'drop'
  )

# Tabla comparativa
kable(estadisticos_tcl,
      caption = "Convergencia de la varianza de las medias muestrales",
      digits = 4,
      col.names = c("n", "Media Obs.", "Var. Obs.", "DE Obs.", 
                    "Var. Teórica", "DE Teórica", "Error Var.")) |> 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) |> 
  add_header_above(c(" " = 1, "Observado" = 3, "Teórico" = 2, "Error" = 1))

# Gráfico de disminución de varianza
ggplot(estadisticos_tcl, aes(x = n)) +
  geom_point(aes(y = varianza_observada, color = "Observada"), size = 3) +
  geom_line(aes(y = varianza_observada, color = "Observada"), linewidth = 1.2) +
  geom_point(aes(y = varianza_teorica, color = "Teórica"), size = 3) +
  geom_line(aes(y = varianza_teorica, color = "Teórica"), linewidth = 1.2) +
  scale_color_manual(values = c("Observada" = "blue", "Teórica" = "red")) +
  labs(title = "Disminución de la Varianza de las Medias Muestrales",
       subtitle = "Var(X̄) = σ²/n",
       x = "Tamaño de muestra (n)",
       y = "Varianza de las medias muestrales",
       color = "Tipo") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```



:::







